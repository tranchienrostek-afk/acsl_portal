<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Recursive Builder</title>
    <style>
        :root {
            --bg: #111827;
            --panel: #1f2937;
            --input-bg: #374151;
            --text: #f3f4f6;
            --accent: #8b5cf6;
            --node-pending: #4b5563;
            --node-active: #f59e0b;
            --node-done: #10b981;
            --line: #6b7280;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* SIDEBAR CONFIG */
        .config-panel {
            width: 320px;
            background: var(--panel);
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 1px; color: var(--accent); }
        h2 { font-size: 0.9rem; margin-bottom: 8px; color: #9ca3af; }

        .control-group { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; border: 1px solid #374151; }
        
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #d1d5db; }
        
        input {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid #4b5563;
            color: white;
            padding: 8px;
            border-radius: 4px;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 1rem;
        }

        .math-symbol { color: var(--accent); font-weight: bold; }

        button {
            padding: 12px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover { filter: brightness(1.2); }
        button.secondary { background: #4b5563; }

        /* VISUALIZATION AREA */
        .viz-area {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            background-image: radial-gradient(#374151 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex;
            justify-content: center;
            padding-top: 50px;
            align-items: flex-start;
        }

        /* TREE NODE CSS */
        .tree {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 10px;
            position: relative;
        }

        .node-content {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--node-pending);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 3px solid var(--line);
            z-index: 2;
            transition: all 0.4s ease;
            position: relative;
        }

        .node-content.active {
            background: var(--node-active);
            transform: scale(1.2);
            box-shadow: 0 0 20px var(--node-active);
            border-color: white;
        }

        .node-content.done {
            background: var(--node-done);
            border-color: #059669;
        }

        .arg-val { font-weight: bold; font-size: 1.1rem; }
        .ret-val { font-size: 0.8rem; color: #111; font-weight: bold; background: rgba(255,255,255,0.8); padding: 2px 5px; border-radius: 4px; margin-top: 2px; display: none;}
        .node-content.done .ret-val { display: block; }

        .children-container {
            display: flex;
            margin-top: 40px; /* Space for lines */
            position: relative;
        }

        /* CONNECTORS (SVG LINES) */
        svg.connector {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        path.edge {
            fill: none;
            stroke: var(--line);
            stroke-width: 2;
            transition: stroke 0.5s;
        }
        
        path.edge.active { stroke: var(--node-active); stroke-width: 3; stroke-dasharray: 5; animation: dash 1s linear infinite; }
        path.edge.done { stroke: var(--node-done); stroke-width: 3; }

        @keyframes dash { to { stroke-dashoffset: -10; } }

        /* LOG PANEL */
        .log-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.85rem;
            overflow-y: auto;
            color: #10b981;
        }
    </style>
</head>
<body>

    <div class="config-panel">
        <h1>Recursive Builder</h1>
        <p style="font-size: 0.8rem; opacity: 0.7;">T·∫°o h√†m f(n) kh√¥ng c·∫ßn code</p>

        <div class="control-group">
            <h2>1. ƒê·∫ßu v√†o (Input)</h2>
            <label>Tham s·ªë g·ªçi ban ƒë·∫ßu (n):</label>
            <input type="number" id="inpN" value="5">
        </div>

        <div class="control-group">
            <h2>2. ƒêi·ªÅu ki·ªán d·ª´ng (Base Case)</h2>
            <label>N·∫øu n th·ªèa m√£n ƒëi·ªÅu ki·ªán:</label>
            <input type="text" id="inpBaseCond" value="n <= 1" placeholder="VD: n <= 1">
            <label>Th√¨ tr·∫£ v·ªÅ gi√° tr·ªã:</label>
            <input type="text" id="inpBaseVal" value="1" placeholder="VD: 1">
        </div>

        <div class="control-group">
            <h2>3. B∆∞·ªõc ƒë·ªá quy (Recursive Step)</h2>
            <label>N·∫øu KH√îNG, tr·∫£ v·ªÅ c√¥ng th·ª©c:</label>
            <div style="font-size:0.8rem; color: orange; margin-bottom:5px">D√πng f(x) ƒë·ªÉ g·ªçi ƒë·ªá quy</div>
            <input type="text" id="inpRecForm" value="n * f(n-1)" placeholder="VD: n * f(n-1)">
        </div>

        <div style="display:flex; gap:10px">
            <button onclick="startVisualization()">CH·∫†Y M√î H√åNH</button>
            <button class="secondary" onclick="reset()">Reset</button>
        </div>
        
        <div class="control-group">
            <label>T·ªëc ƒë·ªô:</label>
            <input type="range" id="speedRange" min="100" max="2000" value="800" style="width:100%">
        </div>
    </div>

    <div class="viz-area" id="vizArea">
        </div>

    <div class="log-panel" id="logPanel">
        > S·∫µn s√†ng...<br>
    </div>

    <script>
        // --- LOGIC PARSER & EXECUTION ENGINE ---
        
        let rootNode = null;
        let stepQueue = [];
        let isRunning = false;
        let animationSpeed = 800;

        // C·∫•u tr√∫c Node cho c√¢y
        class TreeNode {
            constructor(arg, parent = null) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.arg = arg;
                this.parent = parent;
                this.children = [];
                this.result = null;
                this.isBaseCase = false;
                this.formula = ""; 
                this.domElement = null; // Link t·ªõi HTML DIV
            }
        }

        // H√†m ph√¢n t√≠ch c√∫ ph√°p "No-code"
        // M·ª•c ti√™u: Bi·∫øn chu·ªói "n * f(n-1)" th√†nh logic x·ª≠ l√Ω
        function parseAndBuildTree(node, config) {
            const n = node.arg;

            // 1. Ki·ªÉm tra Base Case
            // S·ª≠ d·ª•ng new Function ƒë·ªÉ ƒë√°nh gi√° bi·ªÉu th·ª©c boolean an to√†n trong scope c·ª•c b·ªô
            const checkBase = new Function('n', `return ${config.baseCond};`);
            
            if (checkBase(n)) {
                node.isBaseCase = true;
                // T√≠nh gi√° tr·ªã base value (c√≥ th·ªÉ l√† s·ªë ho·∫∑c bi·ªÉu th·ª©c nh∆∞ 'n')
                const getBaseVal = new Function('n', `return ${config.baseVal};`);
                node.result = getBaseVal(n);
                node.formula = `Base: ${node.result}`;
                return;
            }

            // 2. X·ª≠ l√Ω Recursive Step
            // T√¨m t·∫•t c·∫£ c√°c ƒëo·∫°n g·ªçi h√†m f(...) trong chu·ªói c√¥ng th·ª©c
            // Regex: f\(([^)]+)\) -> t√¨m f(bi·ªÉu_th·ª©c)
            const formulaStr = config.recForm;
            const regex = /f\(([^)]+)\)/g;
            let match;
            
            // L∆∞u l·∫°i c√¥ng th·ª©c g·ªëc nh∆∞ng thay f(...) b·∫±ng placeholder ƒë·ªÉ sau n√†y t√≠nh to√°n
            node.formula = formulaStr; 

            // T√¨m c√°c con c·∫ßn sinh ra
            while ((match = regex.exec(formulaStr)) !== null) {
                const argExpr = match[1]; // L·∫•y n·ªôi dung trong ngo·∫∑c, v√≠ d·ª• "n-1"
                
                // T√≠nh gi√° tr·ªã tham s·ªë m·ªõi cho con
                const calcArg = new Function('n', `return ${argExpr};`);
                const childArg = calcArg(n);

                // T·∫°o node con
                const childNode = new TreeNode(childArg, node);
                node.children.push(childNode);

                // ƒê·ªá quy ti·∫øp t·ª•c x√¢y c√¢y
                parseAndBuildTree(childNode, config);
            }

            // L∆∞u √Ω: Ta ch∆∞a t√≠nh result c·ªßa node n√†y ·ªü ƒë√¢y, 
            // result ch·ªâ ƒë∆∞·ª£c t√≠nh khi c√°c con ƒë√£ c√≥ k·∫øt qu·∫£ (trong giai ƒëo·∫°n animation/execution)
        }

        // --- UI RENDERER ---

        function createTreeHTML(node) {
            const wrapper = document.createElement('div');
            wrapper.className = 'node-wrapper';
            wrapper.id = `wrap-${node.id}`;

            // Node Circle
            const content = document.createElement('div');
            content.className = 'node-content';
            content.id = `node-${node.id}`;
            content.innerHTML = `
                <div class="arg-val">f(${node.arg})</div>
                <div class="ret-val">?</div>
            `;
            node.domElement = content;
            wrapper.appendChild(content);

            // Container for children
            if (node.children.length > 0) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                childrenContainer.id = `children-${node.id}`;
                
                node.children.forEach(child => {
                    childrenContainer.appendChild(createTreeHTML(child));
                });
                wrapper.appendChild(childrenContainer);
            }

            return wrapper;
        }

        function drawLines() {
            // X√≥a lines c≈©
            document.querySelectorAll('svg.connector').forEach(e => e.remove());

            // V·∫Ω line m·ªõi n·ªëi cha-con
            const vizArea = document.getElementById('vizArea');
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.classList.add('connector');
            
            // L·∫•y k√≠ch th∆∞·ªõc to√†n b·ªô v√πng v·∫Ω ƒë·ªÉ set SVG size
            const rect = vizArea.firstChild.getBoundingClientRect(); // L·∫•y wrapper to nh·∫•t
            // Nh∆∞ng ta c·∫ßn to·∫° ƒë·ªô t∆∞∆°ng ƒë·ªëi v·ªõi vizArea
            // C√°ch ƒë∆°n gi·∫£n: Duy·ªát c√¢y data v√† v·∫Ω line gi·ªØa c√°c element ID

            function connect(node) {
                if (!node.children || node.children.length === 0) return;

                const parentEl = document.getElementById(`node-${node.id}`);
                const parentRect = parentEl.getBoundingClientRect();
                const containerRect = vizArea.getBoundingClientRect();

                // To·∫° ƒë·ªô t√¢m cha t∆∞∆°ng ƒë·ªëi v·ªõi vizArea (c√≥ t√≠nh scroll)
                const pX = parentRect.left + parentRect.width/2 - containerRect.left + vizArea.scrollLeft;
                const pY = parentRect.top + parentRect.height - containerRect.top + vizArea.scrollTop;

                node.children.forEach(child => {
                    const childEl = document.getElementById(`node-${child.id}`);
                    const childRect = childEl.getBoundingClientRect();
                    
                    // To·∫° ƒë·ªô t√¢m ƒë·ªânh con
                    const cX = childRect.left + childRect.width/2 - containerRect.left + vizArea.scrollLeft;
                    const cY = childRect.top - containerRect.top + vizArea.scrollTop;

                    // T·∫°o ƒë∆∞·ªùng d·∫´n Bezier
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", `M ${pX} ${pY} C ${pX} ${pY + 20}, ${cX} ${cY - 20}, ${cX} ${cY}`);
                    path.classList.add('edge');
                    path.id = `edge-${node.id}-${child.id}`;
                    svg.appendChild(path);

                    connect(child);
                });
            }

            vizArea.appendChild(svg);
            // C·∫≠p nh·∫≠t l·∫°i k√≠ch th∆∞·ªõc SVG
            svg.setAttribute("width", vizArea.scrollWidth);
            svg.setAttribute("height", vizArea.scrollHeight);
            
            if(rootNode) connect(rootNode);
        }

        // --- ANIMATION ENGINE ---

        function log(msg) {
            const el = document.getElementById('logPanel');
            el.innerHTML += `> ${msg}<br>`;
            el.scrollTop = el.scrollHeight;
        }

        function queueStep(type, node, extra = null) {
            stepQueue.push({ type, node, extra });
        }

        // Duy·ªát c√¢y ƒë·ªÉ t·∫°o k·ªãch b·∫£n Animation (M√¥ ph·ªèng Call Stack th·ª±c t·∫ø)
        function generateAnimationSteps(node, config) {
            // 1. CALL: ƒê√°nh d·∫•u ƒëang ch·∫°y
            queueStep('CALL', node);

            if (node.isBaseCase) {
                // 2. BASE: T√¨m th·∫•y ƒë√°y
                queueStep('BASE_HIT', node);
            } else {
                // 3. RECURSE: G·ªçi c√°c con
                for (let i = 0; i < node.children.length; i++) {
                    generateAnimationSteps(node.children[i], config);
                }
                
                // 4. CALC: Sau khi c√°c con v·ªÅ h·∫øt, t√≠nh k·∫øt qu·∫£ c·ªßa m√¨nh
                queueStep('CALCULATE', node, config.recForm);
            }

            // 5. RETURN: Tr·∫£ k·∫øt qu·∫£ l√™n cha
            queueStep('RETURN', node);
        }

        async function processQueue() {
            if (stepQueue.length === 0) {
                log("HO√ÄN TH√ÄNH!");
                return;
            }

            const step = stepQueue.shift();
            const dom = document.getElementById(`node-${step.node.id}`);

            switch (step.type) {
                case 'CALL':
                    dom.classList.add('active');
                    dom.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
                    log(`G·ªçi h√†m f(${step.node.arg})...`);
                    // Highlight edge from parent
                    if(step.node.parent) {
                        const edge = document.getElementById(`edge-${step.node.parent.id}-${step.node.id}`);
                        if(edge) edge.classList.add('active');
                    }
                    break;

                case 'BASE_HIT':
                    dom.classList.remove('active');
                    dom.classList.add('done');
                    dom.querySelector('.ret-val').textContent = step.node.result;
                    log(`üõë ƒêK d·ª´ng t·∫°i n=${step.node.arg}. Tr·∫£ v·ªÅ ${step.node.result}`);
                    break;

                case 'CALCULATE':
                    // L√∫c n√†y c√°c con ƒë√£ c√≥ result. T√≠nh result cho node n√†y.
                    // L·∫•y gi√° tr·ªã t·ª´ c√°c con
                    let formula = step.extra; // "n * f(n-1)"
                    let formulaLog = formula.replace('n', step.node.arg); // "5 * f(4)"
                    
                    // Regex thay th·∫ø f(...) b·∫±ng gi√° tr·ªã th·ª±c c·ªßa con
                    // Logic n√†y c·∫ßn kh·ªõp v·ªõi th·ª© t·ª± con trong m·∫£ng children
                    let childIndex = 0;
                    // Ta thay th·∫ø l·∫ßn l∆∞·ª£t c√°c f(...) b·∫±ng result c·ªßa con t∆∞∆°ng ·ª©ng
                    const evalString = formula.replace(/f\(([^)]+)\)/g, (match) => {
                        const val = step.node.children[childIndex].result;
                        formulaLog = formulaLog.replace(match, val);
                        childIndex++;
                        return val;
                    });
                    
                    // T√≠nh to√°n cu·ªëi c√πng
                    const finalCalc = new Function('n', `return ${evalString}`);
                    step.node.result = finalCalc(step.node.arg);
                    
                    log(`üîÑ T√≠nh: ${formulaLog} = ${step.node.result}`);
                    break;

                case 'RETURN':
                    dom.classList.remove('active');
                    dom.classList.add('done');
                    dom.querySelector('.ret-val').textContent = step.node.result;
                    
                    // T·∫Øt edge
                    if(step.node.parent) {
                        const edge = document.getElementById(`edge-${step.node.parent.id}-${step.node.id}`);
                        if(edge) {
                            edge.classList.remove('active');
                            edge.classList.add('done');
                        }
                    }
                    break;
            }

            animationSpeed = 2100 - document.getElementById('speedRange').value;
            setTimeout(processQueue, animationSpeed);
        }

        // --- MAIN FUNCTIONS ---

        function startVisualization() {
            const n = parseInt(document.getElementById('inpN').value);
            const baseCond = document.getElementById('inpBaseCond').value;
            const baseVal = document.getElementById('inpBaseVal').value;
            const recForm = document.getElementById('inpRecForm').value;

            // 1. Build Data Tree
            rootNode = new TreeNode(n);
            const config = { baseCond, baseVal, recForm };
            
            try {
                parseAndBuildTree(rootNode, config);
            } catch (e) {
                alert("L·ªói c√¥ng th·ª©c! Vui l√≤ng ki·ªÉm tra l·∫°i c√∫ ph√°p (VD: n <= 1).");
                console.error(e);
                return;
            }

            // 2. Render HTML Structure
            const vizArea = document.getElementById('vizArea');
            vizArea.innerHTML = '';
            vizArea.appendChild(createTreeHTML(rootNode));
            
            // V·∫Ω lines sau khi HTML ƒë√£ render
            setTimeout(() => {
                drawLines();
                
                // 3. Generate & Run Animation
                stepQueue = [];
                generateAnimationSteps(rootNode, config);
                document.getElementById('logPanel').innerHTML = '> B·∫Øt ƒë·∫ßu ch·∫°y...<br>';
                processQueue();
            }, 100);
        }

        function reset() {
            location.reload();
        }

        // Re-draw lines on resize
        window.addEventListener('resize', () => {
            if(rootNode) drawLines();
        });

    </script>
</body>
</html>
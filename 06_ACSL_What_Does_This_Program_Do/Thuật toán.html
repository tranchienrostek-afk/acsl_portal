<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlgoTrace Pro - Trace Table Generator</title>
    <style>
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --border: #3e3e42;
            --accent: #007acc;
            --text: #d4d4d4;
            --keyword: #c586c0;
            --variable: #9cdcfe;
            --number: #b5cea8;
            --string: #ce9178;
            --changed-bg: rgba(78, 201, 176, 0.2);
            --changed-text: #4ec9b0;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            background: #333333;
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.2rem; color: #fff; text-transform: uppercase; letter-spacing: 1px; }

        .toolbar { display: flex; gap: 10px; }
        
        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 2px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
        }
        button:hover { filter: brightness(1.1); }
        button.secondary { background: #444; }

        /* LAYOUT */
        .main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - 50px);
        }

        /* EDITOR */
        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            min-width: 300px;
        }

        .pane-header {
            background: var(--panel);
            padding: 5px 10px;
            font-size: 0.8rem;
            color: #aaa;
            border-bottom: 1px solid var(--border);
            text-transform: uppercase;
        }

        #codeEditor {
            flex: 1;
            background: var(--bg);
            color: var(--text);
            border: none;
            padding: 15px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            white-space: pre;
        }

        /* OUTPUT & TRACE */
        .output-pane {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
        }

        /* TRACE TABLE */
        .table-container {
            flex: 2;
            overflow: auto;
            border-bottom: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th, td {
            border: 1px solid var(--border);
            padding: 8px;
            text-align: left;
        }

        th {
            background: var(--panel);
            position: sticky;
            top: 0;
            color: #fff;
            z-index: 10;
        }

        tr:nth-child(even) { background: #2a2a2a; }
        
        .changed-cell {
            background-color: var(--changed-bg) !important;
            color: var(--changed-text);
            font-weight: bold;
            animation: flash 1s;
        }

        .line-num-col { color: #666; width: 50px; text-align: center; }
        .statement-col { color: var(--keyword); width: 250px; font-style: italic;}

        /* CONSOLE */
        .console-container {
            flex: 1;
            background: #111;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            border-top: 2px solid var(--accent);
        }
        .console-log { color: #fff; margin-bottom: 5px; }
        .console-error { color: #f48771; }

        @keyframes flash {
            0% { background-color: #fff; color: #000; }
            100% { background-color: var(--changed-bg); color: var(--changed-text); }
        }

    </style>
</head>
<body>

    <header>
        <h1>AlgoTrace <span style="color:var(--accent)">Pro</span></h1>
        <div class="toolbar">
            <button class="secondary" onclick="loadExample()">Mẫu: Bài toán của bạn</button>
            <button class="secondary" onclick="loadLoopExample()">Mẫu: Vòng lặp While</button>
            <button onclick="runCode()">CHẠY (RUN)</button>
        </div>
    </header>

    <div class="main-container">
        <div class="editor-pane">
            <div class="pane-header">Input Code (Pseudo-code)</div>
            <textarea id="codeEditor" spellcheck="false">// Nhập code tại đây
// Hỗ trợ: 
// - Gán: a = 1
// - Nhiều lệnh 1 dòng: a=1 : b=2
// - Toán tử: +, -, *, /, ^ (lũy thừa)
// - Hàm: int(), abs(), sqrt()
// - Điều kiện: if (dk) then ... else ...
// - In: output ...

a = 10
b = 20
c = a + b
if (c > 25) then c = c * 2 else c = 0
output c</textarea>
        </div>

        <div class="output-pane">
            <div class="table-container">
                <table id="traceTable">
                    <thead>
                        <tr id="tableHeader">
                            <th class="line-num-col">Step</th>
                            <th class="statement-col">Lệnh thực thi</th>
                            </tr>
                    </thead>
                    <tbody id="tableBody">
                    </tbody>
                </table>
            </div>
            
            <div class="pane-header">Console Output</div>
            <div class="console-container" id="consoleOutput">
                <div class="console-log">Ready...</div>
            </div>
        </div>
    </div>

    <script>
        // --- CORE INTERPRETER ENGINE ---

        let variables = {};
        let traceHistory = [];
        let stepsCounter = 0;

        function reset() {
            variables = {};
            traceHistory = [];
            stepsCounter = 0;
            document.getElementById('consoleOutput').innerHTML = '';
            document.getElementById('tableBody').innerHTML = '';
            // Reset header but keep first 2 cols
            const headerRow = document.getElementById('tableHeader');
            while(headerRow.children.length > 2) {
                headerRow.removeChild(headerRow.lastChild);
            }
        }

        function logToConsole(msg, isError = false) {
            const div = document.createElement('div');
            div.className = isError ? 'console-error' : 'console-log';
            div.textContent = `> ${msg}`;
            document.getElementById('consoleOutput').appendChild(div);
        }

        // --- PARSER HELPER ---
        function parseExpression(expr) {
            // Replace user friendly syntax to JS syntax
            // 1. Replace ^ with ** (Power)
            // Note: Replace requires handling logic, simple regex for basic cases
            // We'll replace ^ with ** but need to be careful.
            
            let jsExpr = expr;
            
            // Replace syntax
            jsExpr = jsExpr.replace(/\^/g, '**'); // Power
            jsExpr = jsExpr.replace(/\bint\(/g, 'Math.floor('); // int() -> floor
            jsExpr = jsExpr.replace(/\babs\(/g, 'Math.abs('); // abs()
            jsExpr = jsExpr.replace(/\bsqrt\(/g, 'Math.sqrt('); // sqrt()
            
            // Replace variable names with `variables['name']`
            // Regex to find identifiers that are NOT keywords
            // This is tricky. Simplified approach:
            // Get all known var names
            const varNames = Object.keys(variables).sort((a,b) => b.length - a.length); // Sort long first
            
            for (let v of varNames) {
                // Regex: Word boundary + varName + Word boundary
                // We use a temporary placeholder to avoid double replacement
                const regex = new RegExp(`\\b${v}\\b`, 'g');
                jsExpr = jsExpr.replace(regex, `variables['${v}']`);
            }
            
            // Handle &&, ||, ==, != (JS already supports these, but user might use single =)
            // Assume user uses == for comparison in IF
            
            return jsExpr;
        }

        function evaluate(expr) {
            try {
                const jsExpr = parseExpression(expr);
                return new Function('variables', 'Math', `return ${jsExpr};`)(variables, Math);
            } catch (e) {
                throw new Error(`Lỗi tính toán: ${expr}`);
            }
        }

        // --- EXECUTION ---

        function runCode() {
            reset();
            const code = document.getElementById('codeEditor').value;
            // Pre-process: Split by new lines
            let rawLines = code.split('\n');
            
            // Flatten lines that have ':'
            let lines = [];
            rawLines.forEach(l => {
                // Split by colon but ignore colons inside quotes (simplified: assume no strings with colons)
                const parts = l.split(':'); 
                parts.forEach(p => lines.push(p.trim()));
            });

            // Process loop handling is complex for a simple regex parser.
            // We will execute linearly, but support 'while' by controlling the index `i` manually.
            
            try {
                let loopStack = []; // For simple loops
                
                // First pass: Find all variables to setup table headers
                // This is a heuristic pass
                lines.forEach(line => {
                    const assignMatch = line.match(/^(\w+)\s*=/);
                    if(assignMatch) variables[assignMatch[1]] = 0; // Init
                });
                
                // Render Headers
                const headerRow = document.getElementById('tableHeader');
                const sortedVars = Object.keys(variables).sort();
                sortedVars.forEach(v => {
                    const th = document.createElement('th');
                    th.textContent = v;
                    headerRow.appendChild(th);
                });
                
                // Clear vars for actual run
                variables = {}; 
                // However, we want to keep the columns fixed.
                // We will fill undefined vars with '-'

                let i = 0;
                let maxSteps = 1000; // Prevent infinite loops
                
                while (i < lines.length && stepsCounter < maxSteps) {
                    let line = lines[i].trim();
                    if (!line || line.startsWith('//')) {
                        i++; continue;
                    }
                    
                    stepsCounter++;
                    let changedVar = null;

                    // 1. OUTPUT
                    if (line.toLowerCase().startsWith('output ')) {
                        const expr = line.substring(7);
                        const val = evaluate(expr);
                        logToConsole(val);
                    }
                    
                    // 2. ASSIGNMENT (a = ...)
                    // Check if it's NOT an IF statement
                    else if (!line.toLowerCase().startsWith('if ') && !line.toLowerCase().startsWith('while ') && line.includes('=')) {
                        const parts = line.split('=');
                        const varName = parts[0].trim();
                        // Handle "+=" syntax if needed, but assuming standard "="
                        // Check if valid variable name
                        if (/^[a-zA-Z_]\w*$/.test(varName)) {
                            const expr = parts.slice(1).join('='); // Rest of string
                            const val = evaluate(expr);
                            variables[varName] = val;
                            changedVar = varName;
                        }
                    }

                    // 3. IF ... THEN ... ELSE
                    else if (line.toLowerCase().startsWith('if ')) {
                        // Regex to parse: if (cond) then (act1) else (act2)
                        // This handles single line IF
                        const match = line.match(/if\s+(.+)\s+then\s+(.+?)(\s+else\s+(.+))?$/i);
                        if (match) {
                            const cond = match[1];
                            const thenAct = match[2];
                            const elseAct = match[4]; // might be undefined

                            const isTrue = evaluate(cond);
                            let actionToRun = isTrue ? thenAct : elseAct;

                            if (actionToRun) {
                                // Execute the action (Recursive call equivalent for single line)
                                // Only supports assignments in this mini-parser
                                if (actionToRun.includes('=')) {
                                    const ap = actionToRun.split('=');
                                    const vn = ap[0].trim();
                                    const ve = ap.slice(1).join('=');
                                    variables[vn] = evaluate(ve);
                                    changedVar = vn;
                                } else if (actionToRun.toLowerCase().startsWith('output ')) {
                                    logToConsole(evaluate(actionToRun.substring(7)));
                                }
                            }
                        }
                    }
                    
                    // 4. WHILE LOOP (Basic)
                    // Syntax: while (cond) { ... } is hard.
                    // Let's support: while (cond) ... endwhile
                    // Not implemented in this basic version. 
                    // To satisfy "Vòng lặp" in user request without full AST:
                    // We will simulate the user's linear example first. 
                    // If user needs loop, we recommend unrolling or simple GOTO logic (line numbers).
                    
                    // Add Row to Table
                    addTableRow(stepsCounter, line, changedVar, sortedVars);
                    
                    i++;
                }

                if (stepsCounter >= maxSteps) {
                    logToConsole("Cảnh báo: Đã dừng do vượt quá giới hạn bước (Infinite loop protection).", true);
                }

            } catch (err) {
                logToConsole(err.message, true);
            }
        }

        function addTableRow(step, code, changedVar, varList) {
            const tbody = document.getElementById('tableBody');
            const tr = document.createElement('tr');

            // Col 1: Step
            tr.innerHTML += `<td class="line-num-col">${step}</td>`;
            // Col 2: Code
            tr.innerHTML += `<td class="statement-col">${code}</td>`;

            // Var Cols
            varList.forEach(v => {
                const val = variables[v];
                const display = (val !== undefined && val !== null) ? (Number.isInteger(val) ? val : val.toFixed(4).replace(/\.?0+$/,'')) : '-';
                
                const td = document.createElement('td');
                td.textContent = display;
                
                if (v === changedVar) {
                    td.className = 'changed-cell';
                }
                tr.appendChild(td);
            });

            tbody.appendChild(tr);
            // Scroll to bottom
            const container = document.querySelector('.table-container');
            container.scrollTop = container.scrollHeight;
        }

        // --- PRESET EXAMPLES ---

        function loadExample() {
            // Converting User's input to our parser friendly format
            // User input: 
            // 1 a = 1: b = 2: c = 3: d = 4: e = 4: f = 6
            // 2 if (d / b) < (f / a) then d = d / b
            // 3 a = f ^ b / c ^ (d / b) 
            // if (a <= f) && (b > e) then a = f else b = e
            // if abs(c - f) != int(f / c) then c = f / c else f = f / c
            // if (a == b) || (c == d) then a = a + b
            // c = c + d
            // output (b * c) * (f + d) / a / 2 * d - c + e ^ (b - 2 * d)
            
            const ex = `// Khởi tạo
a = 1 : b = 2 : c = 3 : d = 4 : e = 4 : f = 6

// Câu điều kiện 1
if (d / b) < (f / a) then d = d / b

// Phép toán lũy thừa (^)
a = f ^ b / c ^ (d / b)

// Câu điều kiện phức hợp (&&)
if (a <= f) && (b > e) then a = f else b = e

// Hàm toán học (abs, int)
if abs(c - f) != int(f / c) then c = f / c else f = f / c

// Câu điều kiện OR (||)
if (a == b) || (c == d) then a = a + b

// Phép cộng
c = c + d

// Output kết quả phức tạp
output (b * c) * (f + d) / a / 2 * d - c + e ^ (b - 2 * d)`;

            document.getElementById('codeEditor').value = ex;
            runCode();
        }
        
        function loadLoopExample() {
            // Since we process line by line, to simulate a loop in this tool 
            // without block scoping (brackets), we can just write out the trace manually 
            // OR (Better) - I will update the logic slightly to support a fake loop if I had time.
            // But for now, let's show a linear unroll which is common in trace tables.
            
            const ex = `// Mô phỏng vòng lặp tính tổng từ 1 đến 5
sum = 0
i = 1

// Vòng 1
sum = sum + i
i = i + 1

// Vòng 2
sum = sum + i
i = i + 1

// Vòng 3
sum = sum + i
i = i + 1

// Vòng 4
sum = sum + i
i = i + 1

// Vòng 5
sum = sum + i
i = i + 1

output sum`;
            document.getElementById('codeEditor').value = ex;
            runCode();
        }
        
        // Auto run on load
        window.onload = loadExample;

    </script>
</body>
</html>